{
    "docs": [
        {
            "location": "/", 
            "text": "Domain Pass-Through for Citrix Receiver for Linux 13.10\n\n\nThis document describes the configuration required for the Authentication Manager component of Citrix Receiver for Linux to support Domain Pass-Through use cases.", 
            "title": "Home"
        }, 
        {
            "location": "/#domain-pass-through-for-citrix-receiver-for-linux-1310", 
            "text": "This document describes the configuration required for the Authentication Manager component of Citrix Receiver for Linux to support Domain Pass-Through use cases.", 
            "title": "Domain Pass-Through for Citrix Receiver for Linux 13.10"
        }, 
        {
            "location": "/authentication-types/", 
            "text": "Domain Pass-Through authentication types\n\n\nStoreFront must be configured through the StoreFront console to offer the relevant protocol to the client. Enable the \u201cDomain pass-through\u201d protocol from the StoreFront console:\n\n\n\n\nNote that other protocols can also be enabled in StoreFront without any negative effect. On the client AM is configured to use only the authentication method required for the Domain Pass-Through case.", 
            "title": "Domain Pass-Through authentication types"
        }, 
        {
            "location": "/authentication-types/#domain-pass-through-authentication-types", 
            "text": "StoreFront must be configured through the StoreFront console to offer the relevant protocol to the client. Enable the \u201cDomain pass-through\u201d protocol from the StoreFront console:   Note that other protocols can also be enabled in StoreFront without any negative effect. On the client AM is configured to use only the authentication method required for the Domain Pass-Through case.", 
            "title": "Domain Pass-Through authentication types"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\nDomain Pass-Through uses Kerberos to authenticate the user to StoreFront, so Kerberos must be properly enabled and configured on the client before attempting an authentication.\n\n\nReceiver settings for Domain Pass-Through\n\n\nTo enable Domain Pass-Through on the Receiver, the following section must be added to the All_Regions.ini file located in the $ICAROOT/config directory:\n\n\n[Logon\\Local Credentials]\u2028UseLocalUserAndPassword=*\u2028EnableSSOThruICAFile=*\u2028SSOnUserSetting=*\n\n\n\n\n\nImportant: In addition to the changes to the All_Regions.ini file, each of these configuration options must be specifically allowed by a line in a lockdown profile. If any of these options are missing or disabled in the lockdown profile, Citrix Receiver cannot use Domain Pass-Through authentication.\u2028Lockdown profiles prevent parameters from being modified in an ICA file. (Other parameters are protected from by other mechanisms.) For more information on lockdown profiles, see the text in All_Regions.ini.\n\n\nNote: Duplicate sections are not allowed in All_Regions.ini. To avoid error messages regarding duplicates, combine sections that have the same name.\n\n\nKerberos installation\n\n\nMost Linux distributions come with basic Kerberos functionality present, namely, at least some of the Kerberos-related packages are preinstalled. Consult the package manager of the Linux distribution that you are using in case you need to install any missing package.\n\n\nUsing Kerberos for Domain Pass-Through requires additional tools that are typically separate from the packages that bring core Kerberos functionality. To take advantage of Domain Pass-Through, you must install the package that includes the tools \nkinit\n, \nklist\n and \nkdestroy\n.\n\u2028For example, on Ubuntu 14.04 LTS, those programs can be installed with the package \nkrb5-user\n.\n\u2028Moreover, if the client has to be configured to obtain Kerberos tickets using public-key credentials such as X.509 certificates or a smart card, any package that allows Kerberos pre-authentication must be installed as well.\u2028Again, for reference, the name of the package that enables such functionality on an Ubuntu 14.4 LTS distribution is \nkrb5-pkinit\n.\n\n\nKerberos configuration\n\n\nTo use Kerberos to authenticate to StoreFront, a ticket-granting ticket (TGT) must first be obtained from the key distribution center (KDC) of the domain.\nBefore requesting a TGT, Kerberos must be configured.\n\u2028The configuration file is typically found at: \n/etc/krb5.conf\n\n\nThis section covers only the basic settings required to enable Kerberos authentication for a single-domain scenario. If your environment is more complex, or if you need a more fine-tuned setup, see the official Kerberos documentation.\n\n\nBasic configuration example\n\n\nThe following configuration example assumes that the KDC resides on the domain controller:\n\n\n[libdefaults]\u2028    default_realm = YOURDOMAIN.NET\n[realms]\u2028    YOURDOMAIN.NET = {\u2028        kdc = yourdc.yourdomain.net\n        admin_server = yourdc.yourdomain.net\n        default_domain = YOURDOMAIN.NET\n    }\n[domain_realm]\n    .yourdomain.net = YOURDOMAIN.NET\n    yourdomain.net = YOURDOMAIN.NET\n\n\n\n\n\nSmart card configuration example\n\n\nThe following configuration example allows for a TGT to be requested using a smart card instead of domain credentials. Again the example assumes that the KDC resides on the domain controller:\n\n\n[libdefaults]\u2028    default_realm = YOURDOMAIN.NET\n[realms]\u2028    YOURDOMAIN.NET = {\u2028        kdc = yourdc.yourdomain.net\n        admin_server = yourdc.yourdomain.net\n        default_domain = YOURDOMAIN.NET\n        pkinit_eku_checking = kpServerAuth\n        pkinit_kdc_hostname = yourdc.yourdomain.net\n        pkinit_anchors = FILE:/path/to/your/root/certificate.pem\n        pkinit_identities = PKCS11:/path/to/your/PKCS11module.so\n    }\n[domain_realm]\n    .yourdomain.net = YOURDOMAIN.NET\n    yourdomain.net = YOURDOMAIN.NET\n\n\n\n\n\nImportant: the name specified under \npkinit_kdc_hostname\n must match exactly the name of your domain controller and is case-sensitive.\n\u2028The value of the field \npkinit_anchors\n is the absolute path of the root PEM certificate to use for the connection to the host specified at \npkinit_kdc_hostname\n.\n\u2028The value of the field \npkinit_identities\n is the absolute path of the PKCS11 module to use to read the contents of the smart card you intend to use to get the Kerberos TGT. For example, on a typical 64 bit Ubuntu 14.04 LTS installation, the module can be found at \n/usr/lib/x86_64-linux-gnu/opensc-pkcs11.so\n.\n\n\nAny change to the Kerberos configuration file takes effect immediately, with no need to restart the service between changes.\n\n\nTest Kerberos configuration\n\n\nTo test the Kerberos configuration, try to obtain a TGT from the KDC.\u2028From the command line, execute:\n\n\nkinit -f username\n\n\nor:\n\n\nkinit -f username@YOURDOMAIN.NET\n\n\nwhere \nusername\n is the name of the user for whom you want to get the TGT. If the domain is not specified, the domain indicated in the configuration file (at \ndefault_realm\n) is used by default.\n\u2028The switch \n-f\n means that you are requesting a forwardable ticket. This might be useful when using the requested TGT to attempt a Kerberos authentication to a remote domain.\n\u2028The command then asks you to provide credentials to complete the operation. Depending on your configuration, those can be either domain credentials or the PIN of the smart card.\n\n\nTo verify whether the previous command succeeded, execute:\n\n\nklist\n\n\nThe above command shows the contents of the ticket cache. If the \nkinit\n request was successful you should see that a TGT had been issued:\n\n\nTicket cache: FILE:/tmp/krb5cc_1000\nDefault principal: username@YOURDOMAIN.NET\n\nValid starting     Expires            Service principal\n09/08/16 10:33:08  09/08/16 20:33:08  krbtgt/YOURDOMAIN.NET@YOURDOMAIN.NET renew until 10/08/16 10:33:00\n\n\n\n\n\nIf you can see something like the above, then Kerberos has been configured correctly and it is ready to use.\n\n\nTo remove all the tickets from the cache, use the command:\n\n\nkdestroy\n\n\nOnce you have obtained the TGT and enabled Domain Pass-Through authentication on StoreFront, you can launch Citrix Receiver and verify that the user for whom you requested a TGT gets logged on automatically and apps/desktops are enumerated:\n\n\n\n\nTo double-check that the Kerberos authentication was successful, launch the klist command again to see if you\u2019ve been issued a ticket for the machine where StoreFront is installed:\n\n\nTicket cache: FILE:/tmp/krb5cc_1000\u2028Default principal: username@YOURDOMAIN.NET\n\nValid starting     Expires            Service principal\u202809/08/16 10:33:08  09/08/16 20:33:08  krbtgt/YOURDOMAIN.NET@YOURDOMAIN.NET\u2028        renew until 10/08/16 10:33:00\u202809/08/16 10:34:32  10/08/16 20:33:08  HTTP/sf.yourdomain.net@YOURDOMAIN.NET\u2028        renew until 10/08/16 10:33:00\n\n\n\n\n\nNotice the presence of a second ticket in the output above.\n\n\nTo launch an app/desktop, you must provide a valid set of credentials using the Credential Insertion SDK, as described in the next section.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "Domain Pass-Through uses Kerberos to authenticate the user to StoreFront, so Kerberos must be properly enabled and configured on the client before attempting an authentication.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#receiver-settings-for-domain-pass-through", 
            "text": "To enable Domain Pass-Through on the Receiver, the following section must be added to the All_Regions.ini file located in the $ICAROOT/config directory:  [Logon\\Local Credentials]\u2028UseLocalUserAndPassword=*\u2028EnableSSOThruICAFile=*\u2028SSOnUserSetting=*  Important: In addition to the changes to the All_Regions.ini file, each of these configuration options must be specifically allowed by a line in a lockdown profile. If any of these options are missing or disabled in the lockdown profile, Citrix Receiver cannot use Domain Pass-Through authentication.\u2028Lockdown profiles prevent parameters from being modified in an ICA file. (Other parameters are protected from by other mechanisms.) For more information on lockdown profiles, see the text in All_Regions.ini.  Note: Duplicate sections are not allowed in All_Regions.ini. To avoid error messages regarding duplicates, combine sections that have the same name.", 
            "title": "Receiver settings for Domain Pass-Through"
        }, 
        {
            "location": "/configuration/#kerberos-installation", 
            "text": "Most Linux distributions come with basic Kerberos functionality present, namely, at least some of the Kerberos-related packages are preinstalled. Consult the package manager of the Linux distribution that you are using in case you need to install any missing package.  Using Kerberos for Domain Pass-Through requires additional tools that are typically separate from the packages that bring core Kerberos functionality. To take advantage of Domain Pass-Through, you must install the package that includes the tools  kinit ,  klist  and  kdestroy .\n\u2028For example, on Ubuntu 14.04 LTS, those programs can be installed with the package  krb5-user .\n\u2028Moreover, if the client has to be configured to obtain Kerberos tickets using public-key credentials such as X.509 certificates or a smart card, any package that allows Kerberos pre-authentication must be installed as well.\u2028Again, for reference, the name of the package that enables such functionality on an Ubuntu 14.4 LTS distribution is  krb5-pkinit .", 
            "title": "Kerberos installation"
        }, 
        {
            "location": "/configuration/#kerberos-configuration", 
            "text": "To use Kerberos to authenticate to StoreFront, a ticket-granting ticket (TGT) must first be obtained from the key distribution center (KDC) of the domain.\nBefore requesting a TGT, Kerberos must be configured.\n\u2028The configuration file is typically found at:  /etc/krb5.conf  This section covers only the basic settings required to enable Kerberos authentication for a single-domain scenario. If your environment is more complex, or if you need a more fine-tuned setup, see the official Kerberos documentation.", 
            "title": "Kerberos configuration"
        }, 
        {
            "location": "/configuration/#basic-configuration-example", 
            "text": "The following configuration example assumes that the KDC resides on the domain controller:  [libdefaults]\u2028    default_realm = YOURDOMAIN.NET\n[realms]\u2028    YOURDOMAIN.NET = {\u2028        kdc = yourdc.yourdomain.net\n        admin_server = yourdc.yourdomain.net\n        default_domain = YOURDOMAIN.NET\n    }\n[domain_realm]\n    .yourdomain.net = YOURDOMAIN.NET\n    yourdomain.net = YOURDOMAIN.NET", 
            "title": "Basic configuration example"
        }, 
        {
            "location": "/configuration/#smart-card-configuration-example", 
            "text": "The following configuration example allows for a TGT to be requested using a smart card instead of domain credentials. Again the example assumes that the KDC resides on the domain controller:  [libdefaults]\u2028    default_realm = YOURDOMAIN.NET\n[realms]\u2028    YOURDOMAIN.NET = {\u2028        kdc = yourdc.yourdomain.net\n        admin_server = yourdc.yourdomain.net\n        default_domain = YOURDOMAIN.NET\n        pkinit_eku_checking = kpServerAuth\n        pkinit_kdc_hostname = yourdc.yourdomain.net\n        pkinit_anchors = FILE:/path/to/your/root/certificate.pem\n        pkinit_identities = PKCS11:/path/to/your/PKCS11module.so\n    }\n[domain_realm]\n    .yourdomain.net = YOURDOMAIN.NET\n    yourdomain.net = YOURDOMAIN.NET  Important: the name specified under  pkinit_kdc_hostname  must match exactly the name of your domain controller and is case-sensitive.\n\u2028The value of the field  pkinit_anchors  is the absolute path of the root PEM certificate to use for the connection to the host specified at  pkinit_kdc_hostname .\n\u2028The value of the field  pkinit_identities  is the absolute path of the PKCS11 module to use to read the contents of the smart card you intend to use to get the Kerberos TGT. For example, on a typical 64 bit Ubuntu 14.04 LTS installation, the module can be found at  /usr/lib/x86_64-linux-gnu/opensc-pkcs11.so .  Any change to the Kerberos configuration file takes effect immediately, with no need to restart the service between changes.", 
            "title": "Smart card configuration example"
        }, 
        {
            "location": "/configuration/#test-kerberos-configuration", 
            "text": "To test the Kerberos configuration, try to obtain a TGT from the KDC.\u2028From the command line, execute:  kinit -f username  or:  kinit -f username@YOURDOMAIN.NET  where  username  is the name of the user for whom you want to get the TGT. If the domain is not specified, the domain indicated in the configuration file (at  default_realm ) is used by default.\n\u2028The switch  -f  means that you are requesting a forwardable ticket. This might be useful when using the requested TGT to attempt a Kerberos authentication to a remote domain.\n\u2028The command then asks you to provide credentials to complete the operation. Depending on your configuration, those can be either domain credentials or the PIN of the smart card.  To verify whether the previous command succeeded, execute:  klist  The above command shows the contents of the ticket cache. If the  kinit  request was successful you should see that a TGT had been issued:  Ticket cache: FILE:/tmp/krb5cc_1000\nDefault principal: username@YOURDOMAIN.NET\n\nValid starting     Expires            Service principal\n09/08/16 10:33:08  09/08/16 20:33:08  krbtgt/YOURDOMAIN.NET@YOURDOMAIN.NET renew until 10/08/16 10:33:00  If you can see something like the above, then Kerberos has been configured correctly and it is ready to use.  To remove all the tickets from the cache, use the command:  kdestroy  Once you have obtained the TGT and enabled Domain Pass-Through authentication on StoreFront, you can launch Citrix Receiver and verify that the user for whom you requested a TGT gets logged on automatically and apps/desktops are enumerated:   To double-check that the Kerberos authentication was successful, launch the klist command again to see if you\u2019ve been issued a ticket for the machine where StoreFront is installed:  Ticket cache: FILE:/tmp/krb5cc_1000\u2028Default principal: username@YOURDOMAIN.NET\n\nValid starting     Expires            Service principal\u202809/08/16 10:33:08  09/08/16 20:33:08  krbtgt/YOURDOMAIN.NET@YOURDOMAIN.NET\u2028        renew until 10/08/16 10:33:00\u202809/08/16 10:34:32  10/08/16 20:33:08  HTTP/sf.yourdomain.net@YOURDOMAIN.NET\u2028        renew until 10/08/16 10:33:00  Notice the presence of a second ticket in the output above.  To launch an app/desktop, you must provide a valid set of credentials using the Credential Insertion SDK, as described in the next section.", 
            "title": "Test Kerberos configuration"
        }, 
        {
            "location": "/credential-insertion-sdk/", 
            "text": "Credential Insertion SDK\n\n\nThe Credential Insertion SDK allows you to insert a set of credentials into AM\u2019s internal cache in order to be used to authenticate the user when launching an app/desktop.\n\n\nThe Credential Insertion SDK is a C/C++ library that must be consumed by external source code. The library exposes a set of functions that provide a convenient way to add and remove domain or smart card credentials to and from the AM\u2019s internal cache.\n\n\nOnce credentials are made available to AM, it can then use them to authenticate the user in a SSO fashion.\n\n\nAPI functions\n\n\nThe CredInject API provides four functions to enable the use of SSO:\n\n\n\n\nLogonSSOUser\n\n\nLogonSSOUserWithPin\n\n\nLogoffSSOUser\n\n\nErrorDescription\n\n\n\n\nThe function is available under the namespace CitrixSSOnSDK.\n\n\nLogonSSOUser\n\n\nLOGONSSOUSER_ERROR_CODE LogonSsoUser    (const wchar_t *username, \n                                             const wchar_t *domain,\n                                             const wchar_t *password);\n\n\n\n\n\nThis function is used to provide user credentials to SSO.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nusername\n\n\nThe username\n\n\n\n\n\n\ndomain\n\n\nThe domain\n\n\n\n\n\n\npassword\n\n\nThe password\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLOGONSSOUSER_OK\n\n\nOperation completed\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_PARAMETER\n\n\nInvalid parameter passed to the function\n\n\n\n\n\n\nLOGONSSOUSER_INITIALIZATION_FAILED\n\n\nAn error occurred initializing the SSO client\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO\n\n\nUnable to connect to the SSO service (AM)\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_SEND_REQUEST\n\n\nUnable to send the request to the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE\n\n\nUnable to receive the response from the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_REQUEST_TYPE\n\n\nInvalid SSO request type\n\n\n\n\n\n\nLOGONSSOUSER_CONTAINER_FULL\n\n\nThe SSO container is full and cannot store more credentials\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_INTERNAL_ERROR\n\n\nAn error has occurred in AM while processing the request\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_IPC_ERROR\n\n\nAn error has occurred during the IPC communication with the server (AM)\n\n\n\n\n\n\n\n\nLogonSsoUserWithPin\n\n\nLOGONSSOUSER_ERROR_CODE LogonSsoUserWithPin(const wchar_t *pin)\n\n\n\n\n\nThis function is used to provide smart card user credentials to SSO.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npin\n\n\nThe smart card PIN\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLOGONSSOUSER_OK\n\n\nOperation completed\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_PARAMETER\n\n\nInvalid parameter passed to the function\n\n\n\n\n\n\nLOGONSSOUSER_INITIALIZATION_FAILED\n\n\nAn error occurred initializing the SSO client\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO\n\n\nUnable to connect to the SSO service (AM)\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_SEND_REQUEST\n\n\nUnable to send the request to the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE\n\n\nUnable to receive the response from the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_REQUEST_TYPE\n\n\nInvalid SSO request type\n\n\n\n\n\n\nLOGONSSOUSER_CONTAINER_FULL\n\n\nThe SSO container is full and cannot store more credentials\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_INTERNAL_ERROR\n\n\nAn error has occurred in AM while processing the request\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_IPC_ERROR\n\n\nAn error has occurred during the IPC communication with the server (AM)\n\n\n\n\n\n\n\n\nLogoffSsoUser\n\n\nint LogoffSsoUser()\n\n\n\n\n\nThis function removes the credentials of the current SSO user and restores the previous user\u2019s credentials if available.\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLOGONSSOUSER_OK\n\n\nOperation completed\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_PARAMETER\n\n\nInvalid parameter passed to the function\n\n\n\n\n\n\nLOGONSSOUSER_INITIALIZATION_FAILED\n\n\nAn error occurred initializing the SSO client\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO\n\n\nUnable to connect to the SSO service (AM)\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_SEND_REQUEST\n\n\nUnable to send the request to the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE\n\n\nUnable to receive the response from the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_REQUEST_TYPE\n\n\nInvalid SSO request type\n\n\n\n\n\n\nLOGONSSOUSER_UNAUTHORIZED\n\n\nTrying to remove a set of credentials that was stored in SSO by AM itself\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_INTERNAL_ERROR\n\n\nAn error has occurred in AM while processing the request\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_IPC_ERROR\n\n\nAn error has occurred during the IPC communication with the server (AM)\n\n\n\n\n\n\n\n\nErrorDescription\n\n\nconst wchar_t *ErrorDescription(LOGONSSOUSER_ERROR_CODE errorCode)\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nerrorCode\n\n\nThe error code to get the description of\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nThe error description\n\n\nThe error description string, or an \u201cUnknown error\u201d message if the error code is unknown", 
            "title": "Credential Insertion SDK"
        }, 
        {
            "location": "/credential-insertion-sdk/#credential-insertion-sdk", 
            "text": "The Credential Insertion SDK allows you to insert a set of credentials into AM\u2019s internal cache in order to be used to authenticate the user when launching an app/desktop.  The Credential Insertion SDK is a C/C++ library that must be consumed by external source code. The library exposes a set of functions that provide a convenient way to add and remove domain or smart card credentials to and from the AM\u2019s internal cache.  Once credentials are made available to AM, it can then use them to authenticate the user in a SSO fashion.", 
            "title": "Credential Insertion SDK"
        }, 
        {
            "location": "/credential-insertion-sdk/#api-functions", 
            "text": "The CredInject API provides four functions to enable the use of SSO:   LogonSSOUser  LogonSSOUserWithPin  LogoffSSOUser  ErrorDescription   The function is available under the namespace CitrixSSOnSDK.", 
            "title": "API functions"
        }, 
        {
            "location": "/credential-insertion-sdk/#logonssouser", 
            "text": "LOGONSSOUSER_ERROR_CODE LogonSsoUser    (const wchar_t *username, \n                                             const wchar_t *domain,\n                                             const wchar_t *password);  This function is used to provide user credentials to SSO.     Parameter  Description      username  The username    domain  The domain    password  The password        Return value  Description      LOGONSSOUSER_OK  Operation completed    LOGONSSOUSER_INVALID_PARAMETER  Invalid parameter passed to the function    LOGONSSOUSER_INITIALIZATION_FAILED  An error occurred initializing the SSO client    LOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO  Unable to connect to the SSO service (AM)    LOGONSSOUSER_UNABLE_TO_SEND_REQUEST  Unable to send the request to the SSO service    LOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE  Unable to receive the response from the SSO service    LOGONSSOUSER_INVALID_REQUEST_TYPE  Invalid SSO request type    LOGONSSOUSER_CONTAINER_FULL  The SSO container is full and cannot store more credentials    LOGONSSOUSER_SERVER_INTERNAL_ERROR  An error has occurred in AM while processing the request    LOGONSSOUSER_SERVER_IPC_ERROR  An error has occurred during the IPC communication with the server (AM)", 
            "title": "LogonSSOUser"
        }, 
        {
            "location": "/credential-insertion-sdk/#logonssouserwithpin", 
            "text": "LOGONSSOUSER_ERROR_CODE LogonSsoUserWithPin(const wchar_t *pin)  This function is used to provide smart card user credentials to SSO.     Parameter  Description      pin  The smart card PIN        Return value  Description      LOGONSSOUSER_OK  Operation completed    LOGONSSOUSER_INVALID_PARAMETER  Invalid parameter passed to the function    LOGONSSOUSER_INITIALIZATION_FAILED  An error occurred initializing the SSO client    LOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO  Unable to connect to the SSO service (AM)    LOGONSSOUSER_UNABLE_TO_SEND_REQUEST  Unable to send the request to the SSO service    LOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE  Unable to receive the response from the SSO service    LOGONSSOUSER_INVALID_REQUEST_TYPE  Invalid SSO request type    LOGONSSOUSER_CONTAINER_FULL  The SSO container is full and cannot store more credentials    LOGONSSOUSER_SERVER_INTERNAL_ERROR  An error has occurred in AM while processing the request    LOGONSSOUSER_SERVER_IPC_ERROR  An error has occurred during the IPC communication with the server (AM)", 
            "title": "LogonSsoUserWithPin"
        }, 
        {
            "location": "/credential-insertion-sdk/#logoffssouser", 
            "text": "int LogoffSsoUser()  This function removes the credentials of the current SSO user and restores the previous user\u2019s credentials if available.     Return value  Description      LOGONSSOUSER_OK  Operation completed    LOGONSSOUSER_INVALID_PARAMETER  Invalid parameter passed to the function    LOGONSSOUSER_INITIALIZATION_FAILED  An error occurred initializing the SSO client    LOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO  Unable to connect to the SSO service (AM)    LOGONSSOUSER_UNABLE_TO_SEND_REQUEST  Unable to send the request to the SSO service    LOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE  Unable to receive the response from the SSO service    LOGONSSOUSER_INVALID_REQUEST_TYPE  Invalid SSO request type    LOGONSSOUSER_UNAUTHORIZED  Trying to remove a set of credentials that was stored in SSO by AM itself    LOGONSSOUSER_SERVER_INTERNAL_ERROR  An error has occurred in AM while processing the request    LOGONSSOUSER_SERVER_IPC_ERROR  An error has occurred during the IPC communication with the server (AM)", 
            "title": "LogoffSsoUser"
        }, 
        {
            "location": "/credential-insertion-sdk/#errordescription", 
            "text": "const wchar_t *ErrorDescription(LOGONSSOUSER_ERROR_CODE errorCode)     Parameter  Description      errorCode  The error code to get the description of        Return value  Description      The error description  The error description string, or an \u201cUnknown error\u201d message if the error code is unknown", 
            "title": "ErrorDescription"
        }, 
        {
            "location": "/api-examples/", 
            "text": "API examples\n\n\nThe following are simple examples that show how to consume the Credential Insertion API.\n\n\nExample 1: Log on a user\n\n\nThe following code provides user credentials to SSO to log on a user.\n\n\nbool\n \nDoLogonSsoUser\n(\nconst\n \nstd\n::\nwstring\n \nusername\n,\n\n                    \nconst\n \nstd\n::\nwstring\n \ndomain\n,\n\n                    \nconst\n \nstd\n::\nwstring\n \npassword\n)\n\n\n{\n\n    \nif\n \n(username.empty()\n\n            \n||\n \npassword.empty()\n\n            \n||\n \ndomain.empty())\n\n    \n{\n\n        \n//\n \nCredentials\n \nunavailable\n \nor\n \nincomplete.\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n//\n \nCredentials\n \nare\n \navailable\n,\n \ninject\n \nthem\n \nto\n \nSSO\n.\n\n    \nCitrixSSOnSDK\n::\nLOGONSSOUSER_ERROR_CODE\n \nresult\n \n=\n\n        \nCitrixSSOnSDK\n::\nLogonSsoUser\n(\nusername\n.\nc_str\n(),\n\n                                    \ndomain\n.\nc_str\n(),\n\n                                    \npassword\n.\nc_str\n());\n\n\n    \n//\n \nCheck\n \nwhether\n \nthe\n \ncredential\n \ninjection\n \nwas\n \nsuccessful\n.\n\n    \nif\n \n(\nresult\n \n!=\n \nCitrixSSOnSDK\n::\nLOGONSSOUSER_OK\n)\n\n    \n{\n\n        \n//\n \nGet\n \nthe\n \nresult\n \ndescription.\n\n        \nconst\n \nwchar_t\n \n*result_description\n \n=\n \nCitrixSSOnSDK\n:\n:\nErrorDescription\n(\nresult\n);\n\n\n        \n//\n \nReport\n \nthe\n \nerror.\n\n        \nwprintf(L\nLogonSsoUser()\n \nfailed\n:\n \n%\nd\n \n%\nls\n\\\nn\n,\n \nresult\n,\n \nresult_description\n);\n\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n//\n \nSuccess\n.\n\n    \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\nExample 2: Log on a user with a smart card\n\n\nThe following code provides user credentials to SSO to log on a user with a smart card.\n\n\nbool\n \nDoLogonSsoUserWithPin\n(\nconst\n \nstd\n::\nwstring\n \npin\n)\n\n\n{\n\n    \nif\n \n(pin.empty())\n\n    \n{\n\n        \n//\n \nPIN\n \nunavailable.\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n//\n \nPIN\n \nis\n \navailable\n,\n \ninject\n \nit\n \nto\n \nSSO\n.\n\n    \nCitrixSSOnSDK\n::\nLOGONSSOUSER_ERROR_CODE\n \nresult\n \n=\n\n        \nCitrixSSOnSDK\n::\nLogonSsoUserWithPin\n(\npin\n.\nc_str\n());\n\n\n    \n//\n \nCheck\n \nwhether\n \nthe\n \nPIN\n \ninjection\n \nwas\n \nsuccessful\n.\n\n    \nif\n \n(\nresult\n \n!=\n \nCitrixSSOnSDK\n::\nLOGONSSOUSER_OK\n)\n\n    \n{\n\n        \n//\n \nGet\n \nthe\n \nresult\n \ndescription.\n\n        \nconst\n \nwchar_t\n \n*result_description\n \n=\n \nCitrixSSOnSDK\n:\n:\nErrorDescription\n(\nresult\n);\n\n\n        \n//\n \nReport\n \nthe\n \nerror.\n\n        \nwprintf(L\nLogonSsoUserWithPin()\n \nfailed\n:\n \n%\nd\n \n%\nls\n\\\nn\n,\n \nresult\n,\n \nresult_description\n);\n\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n//\n \nSuccess\n.\n\n    \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\nExample 3: Log off a user\n\n\nThis function performs a logoff from a SSO perspective, removing the user\u2019s credentials from the system for the purposes of future SSO-based authorization. Existing authorized sessions can still be used.\n\n\nvoid DoLogoffSsoUser()\n{\n    if (CitrixSSOnSDK::LogoffSsoUser() == LOGONSSOUSER_OK)\n        printf(\n\\nUser logged off\\n\n);\n    else\n        printf(\n\\nError logging off user\\n\n);\n}\n\n\n\n\n\nLaunch an app/desktop\n\n\nAfter you have insert the credentials using the Credential Insertion SDK, click on an app/desktop to launch it.\n\u2028If the credentials provided with the API are valid, the app/desktop starts without prompting for user authentication.", 
            "title": "API Examples"
        }, 
        {
            "location": "/api-examples/#api-examples", 
            "text": "The following are simple examples that show how to consume the Credential Insertion API.", 
            "title": "API examples"
        }, 
        {
            "location": "/api-examples/#example-1-log-on-a-user", 
            "text": "The following code provides user credentials to SSO to log on a user.  bool   DoLogonSsoUser ( const   std :: wstring   username , \n                     const   std :: wstring   domain , \n                     const   std :: wstring   password )  { \n     if   (username.empty() \n             ||   password.empty() \n             ||   domain.empty()) \n     { \n         //   Credentials   unavailable   or   incomplete. \n         return   false ; \n     } \n\n     //   Credentials   are   available ,   inject   them   to   SSO . \n     CitrixSSOnSDK :: LOGONSSOUSER_ERROR_CODE   result   = \n         CitrixSSOnSDK :: LogonSsoUser ( username . c_str (), \n                                     domain . c_str (), \n                                     password . c_str ()); \n\n     //   Check   whether   the   credential   injection   was   successful . \n     if   ( result   !=   CitrixSSOnSDK :: LOGONSSOUSER_OK ) \n     { \n         //   Get   the   result   description. \n         const   wchar_t   *result_description   =   CitrixSSOnSDK : : ErrorDescription ( result ); \n\n         //   Report   the   error. \n         wprintf(L LogonSsoUser()   failed :   % d   % ls \\ n ,   result ,   result_description ); \n\n         return   false ; \n     } \n\n     //   Success . \n     return   true ;  }", 
            "title": "Example 1: Log on a user"
        }, 
        {
            "location": "/api-examples/#example-2-log-on-a-user-with-a-smart-card", 
            "text": "The following code provides user credentials to SSO to log on a user with a smart card.  bool   DoLogonSsoUserWithPin ( const   std :: wstring   pin )  { \n     if   (pin.empty()) \n     { \n         //   PIN   unavailable. \n         return   false ; \n     } \n\n     //   PIN   is   available ,   inject   it   to   SSO . \n     CitrixSSOnSDK :: LOGONSSOUSER_ERROR_CODE   result   = \n         CitrixSSOnSDK :: LogonSsoUserWithPin ( pin . c_str ()); \n\n     //   Check   whether   the   PIN   injection   was   successful . \n     if   ( result   !=   CitrixSSOnSDK :: LOGONSSOUSER_OK ) \n     { \n         //   Get   the   result   description. \n         const   wchar_t   *result_description   =   CitrixSSOnSDK : : ErrorDescription ( result ); \n\n         //   Report   the   error. \n         wprintf(L LogonSsoUserWithPin()   failed :   % d   % ls \\ n ,   result ,   result_description ); \n\n         return   false ; \n     } \n\n     //   Success . \n     return   true ;  }", 
            "title": "Example 2: Log on a user with a smart card"
        }, 
        {
            "location": "/api-examples/#example-3-log-off-a-user", 
            "text": "This function performs a logoff from a SSO perspective, removing the user\u2019s credentials from the system for the purposes of future SSO-based authorization. Existing authorized sessions can still be used.  void DoLogoffSsoUser()\n{\n    if (CitrixSSOnSDK::LogoffSsoUser() == LOGONSSOUSER_OK)\n        printf( \\nUser logged off\\n );\n    else\n        printf( \\nError logging off user\\n );\n}", 
            "title": "Example 3: Log off a user"
        }, 
        {
            "location": "/api-examples/#launch-an-appdesktop", 
            "text": "After you have insert the credentials using the Credential Insertion SDK, click on an app/desktop to launch it.\n\u2028If the credentials provided with the API are valid, the app/desktop starts without prompting for user authentication.", 
            "title": "Launch an app/desktop"
        }
    ]
}